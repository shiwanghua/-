{"title":"连通无向图与割点","date":"2019-09-23T13:49:26.000Z","date_formatted":{"ll":"Sep 23, 2019","L":"09/23/2019","MM-DD":"09-23"},"link":"2019/09/23/连通无向图与割点","updated":"2019-09-25T15:52:29.996Z","content":"<ul>\n<li>无向图中，非树边只会以返祖边的形式存在。</li>\n<li>割点分为两种情况<ol>\n<li>DFS 树的根节点有多于一个的子节点，那么根节点就是割点</li>\n<li>对于非根节点 u，它至少有一颗子树没有返祖边可以到达 u 的祖先，则 u 是割点</li>\n</ol>\n</li>\n<li>对于第二种情况，可以这样理解。假设非根节点 u 的某棵子树中有一个结点 x 具有返祖边可以到达 u 的祖先结点。由于图是连通的，那么节点 x 便可以到达 u 上方的所有节点。同时，由于 x 在 u 的子树中，所以 x 可以到达该子树中的所有节点，所以删除节点 u 后，u 上方的所有节点仍可以通过节点 x 与包含 x 的 u 的子树相连。如果 u 的所有子树中都有这样的 x 节点，那么删除 u 节点后，整张图还是连通的，u 不是割点。如果 u 有一颗或多棵子树，这些子树中没有这样的 x 节点，那么删除 u 后，这些子树就不在与图中剩余的部分连通，那么 u 是一个割点。</li>\n<li>求解割点时，每个节点需要维护下面几个信息<ol>\n<li>NUM(x) 表示节点 x 是在 DFS 中第几个被遍历到的点。维护这一信息十分有用，因为如果点 a 是点 b 的祖先，那么 NUM(a)&lt;NUM(b)。</li>\n<li>low(x) 表示节点 x 能通过返祖边到达的 NUM 值最小的祖先的 NUM 的值。初始值为 NUM(x)。</li>\n<li>fa(x) 表示 x 的父节点。在求割边时，fa(x) 记录 x 与其祖先之间的边的编号。</li>\n</ol>\n</li>\n<li>在 DFS 遍历时维护上面提到的那几个信息，回溯时进行判断。如果 low(v)&gt;NUM(x)（v 是 x 的儿子）说明 x 是割点</li>\n</ul>\n","prev":{"title":"C++双端队列","link":"2019/10/03/C-双端队列"},"next":{"title":"使用 Hexo 和 Git Page 搭建博客","link":"2019/04/16/使用-Hexo-和-Git-Page-搭建博客"},"plink":"http://hespoon.github.io/2019/09/23/连通无向图与割点/"}